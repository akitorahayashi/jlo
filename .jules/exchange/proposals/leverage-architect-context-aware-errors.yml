schema_version: 1

id: "e3r7h1"
role: "leverage_architect"

created_at: "2024-05-23"

title: "Context-Aware Error Architecture"
problem: |
  The current error handling strategy relies on a monolithic `AppError` enum in `src/domain/error.rs` that aggregates all possible failure modes (IO, Git, Config, API, etc.) into a single flat structure. This design couples unrelated domains, making it difficult to handle specific errors (e.g., distinguishing a recoverable Git failure from a fatal configuration error) without extensive pattern matching. Furthermore, it often discards the "why" (context) of an error in favor of the "what" (category), leading to vague error messages that hinder debugging and operational visibility.
introduction: |
  Replace the monolithic `AppError` with a layered error handling architecture. Introduce specific, strongly-typed error enums for distinct domain boundaries (e.g., `ConfigError`, `GitError`, `WorkflowError`) using `thiserror` to maintain clear library-level contracts. At the application layer (CLI/commands), utilize `anyhow` (or a similar context-capturing crate) to wrap these domain errors with high-level context, preserving the original cause while adding actionable information for the user.
importance: |
  Reliable systems communicate failure clearly. By decomposing the monolithic error type, we enforce clearer boundaries between components and enable more precise error handling logic (e.g., retries for transient network errors but fast failure for config errors). Context-aware errors significantly reduce mean-time-to-resolution for operational issues by providing a full causality chain rather than a generic error code.

impact_surface:
  - "src/domain/error.rs (Decompose into domain-specific errors)"
  - "src/adapters/ (Update to return specific errors)"
  - "src/app/ (Update to use `anyhow` for context and reporting)"
  - "All function signatures returning `Result<T, AppError>`"

implementation_cost: |
  High. This is a pervasive refactoring that touches almost every function signature in the codebase. It requires a systematic migration strategy, likely starting with the most isolated modules (e.g., `config`, `git`) and working outwards to the application layer.

consistency_risks:
  - "Temporary loss of specific error handling logic during the transition."
  - "Inconsistent error reporting styles if the migration is partial."

verification_signals:
  - "Elimination of the monolithic `AppError` enum or its reduction to a top-level facade only."
  - "Presence of specific error types (e.g., `GitError`) in domain module interfaces."
  - "CLI output demonstrates chained error context (e.g., 'Failed to run workflow: Git error: repository not found' instead of just 'Git error')."
