（Actions実装）の全体フローは、これで確定。 1. 起動方式 すべて GitHub Actions から jules-invoke を使って起動する。各起動は starting_branch: main を指定し、常に main 起点で作業する。 2. Observer（cron・並列） * cronで複数Observerを matrix で並列起動する。 * 各Observerは .jules/（主に exchange/events や notes 等）を更新し、jules/observer-* ブランチでPRを作る。 * これらのPRは（CIが通る限り）自動マージ対象。 3. Decider（cron・Observerの後） * Observer開始から約30分後に cron でDeciderを起動する。 * Deciderは main の最新状態を読み、eventsから .jules/exchange/issues/*.yml を生成し、jules/decider-* PRを作る。 * これも（CIが通る限り）自動マージ対象。 4. Planner（issues件数ぶん matrix） * main への更新を契機に、追加/更新された .jules/exchange/issues/*.yml を列挙する。 * 列挙されたissueファイルの件数ぶん matrix でPlannerを起動する。 * 各Plannerは対応するissueから .jules/exchange/tasks/*.yml を生成し、jules/planner-* PRを作る。 * これも（CIが通る限り）自動マージ対象。 5. Implementation（tasks件数ぶん matrix） * main への更新を契機に、追加/更新された .jules/exchange/tasks/*.yml を列挙する。 * 列挙されたtaskファイルの件数ぶん matrix で実装者を起動する。 * 実装者は対応taskを実装し、実装PR（ブランチは impl/*）を作る。 * 実装PR内で、対応するtaskファイルは削除済みにする。 * 実装PRは自動マージしない。必ず人間レビューで止める。 6. マージ方針（2系統） * jules/*（Observer/Decider/Planner）のPRのみ自動マージ（squash）。 * impl/*（実装PR）は自動マージ禁止（レビュー必須）。 * コンフリクトやCI失敗は「マージされない＝止まる」が正しい。 このフローにより、観測→集約→計画→実装PR生成までがドミノ的に連鎖し、運用PRは自動で流れ、本番コード変更だけがレビューで止まる。