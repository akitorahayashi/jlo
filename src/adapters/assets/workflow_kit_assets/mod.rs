mod action_dirs;
mod asset_collect;
mod render_plan;
mod template_engine;

use include_dir::{Dir, include_dir};
use minijinja::context;

use crate::domain::{AppError, WorkflowRunnerMode};
use crate::ports::ScaffoldFile;

use self::action_dirs::collect_action_dirs;
use self::asset_collect::{AssetSourceFile, collect_asset_sources};
use self::render_plan::should_render_asset;
use self::template_engine::{build_template_environment, render_template_by_name};

static WORKFLOWS_ASSET_DIR: Dir = include_dir!("$CARGO_MANIFEST_DIR/src/assets/workflows/.github");

#[derive(Debug)]
pub struct WorkflowKitAssets {
    pub files: Vec<ScaffoldFile>,
    pub action_dirs: Vec<String>,
}

pub fn load_workflow_kit(mode: WorkflowRunnerMode) -> Result<WorkflowKitAssets, AppError> {
    let sources = collect_asset_sources(&WORKFLOWS_ASSET_DIR)?;
    if sources.is_empty() {
        return Err(AppError::InternalError(format!(
            "Workflow kit assets are empty for mode '{}'",
            mode.label()
        )));
    }

    let env = build_template_environment(&sources)?;

    let runner = match mode {
        WorkflowRunnerMode::Remote => "ubuntu-latest",
        WorkflowRunnerMode::SelfHosted => "self-hosted",
    };
    let ctx = context! {
        runner => runner,
    };

    let mut files = render_scaffold_files(&sources, &env, &ctx)?;

    for file in &mut files {
        file.path = format!(".github/{}", file.path);
        apply_generated_notice(file);
    }

    files.sort_by(|a, b| a.path.cmp(&b.path));

    if files.is_empty() {
        return Err(AppError::InternalError(format!(
            "No renderable workflow kit assets for mode '{}'",
            mode.label()
        )));
    }

    let action_dirs = collect_action_dirs(&files);
    Ok(WorkflowKitAssets { files, action_dirs })
}

const GENERATED_NOTICE: &str =
    "# This file is generated by the jlo CLI; edits are not recommended.\n";

fn apply_generated_notice(file: &mut ScaffoldFile) {
    if !is_jules_workflow_file(&file.path) {
        return;
    }

    if file.content.starts_with(GENERATED_NOTICE) {
        return;
    }

    let mut content = String::with_capacity(GENERATED_NOTICE.len() + file.content.len());
    content.push_str(GENERATED_NOTICE);
    content.push_str(&file.content);
    file.content = content;
}

fn is_jules_workflow_file(path: &str) -> bool {
    path.starts_with(".github/workflows/jules-")
        && (path.ends_with(".yml") || path.ends_with(".yaml"))
}

fn render_scaffold_files(
    sources: &[AssetSourceFile],
    env: &minijinja::Environment<'_>,
    ctx: &minijinja::Value,
) -> Result<Vec<ScaffoldFile>, AppError> {
    let mut files = Vec::new();

    for source in sources {
        if !should_render_asset(source) {
            continue;
        }

        let rendered_content = if source.is_template() {
            render_template_by_name(env, source.template_name(), ctx)?
        } else {
            source.content.clone()
        };

        files.push(ScaffoldFile { path: source.output_path(), content: rendered_content });
    }

    Ok(files)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn workflow_kit_assets_load() {
        let remote = load_workflow_kit(WorkflowRunnerMode::Remote).expect("remote assets");
        assert!(!remote.files.is_empty(), "remote kit should have files");

        let self_hosted =
            load_workflow_kit(WorkflowRunnerMode::SelfHosted).expect("self-hosted assets");
        assert!(!self_hosted.files.is_empty(), "self-hosted kit should have files");
    }
}
