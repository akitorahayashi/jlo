//! Script and config generator service.

use std::collections::BTreeMap;
use std::path::Path;

use crate::domain::AppError;
use crate::domain::setup::Component;

/// Service for generating setup scripts and configuration files.
pub struct Generator;

impl Generator {
    const SCRIPT_HEADER: &'static str = r#"#!/usr/bin/env bash
set -euo pipefail

# Generated by jlo setup
# Do not edit manually - regenerate with 'jlo setup gen'

"#;

    /// Generate install.sh content from resolved components.
    pub fn generate_install_script(components: &[Component]) -> String {
        let mut parts = vec![Self::SCRIPT_HEADER.to_string()];

        for component in components {
            parts.push(
                "# =============================================================================="
                    .to_string(),
            );
            parts.push(format!("# {}: {}", component.name, component.summary));
            parts.push(
                "# =============================================================================="
                    .to_string(),
            );
            parts.push(String::new());
            parts.push(component.script_content.trim().to_string());
            parts.push(String::new());
            parts.push(String::new());
        }

        parts.join("\n")
    }

    /// Generate or merge env.toml content.
    ///
    /// Preserves existing values while adding new keys from components.
    pub fn merge_env_toml(
        components: &[Component],
        existing_path: Option<&Path>,
    ) -> Result<String, AppError> {
        // Load existing values
        let existing = if let Some(path) = existing_path {
            if path.exists() {
                let content = std::fs::read_to_string(path)?;
                Self::parse_env_toml(&content)?
            } else {
                BTreeMap::new()
            }
        } else {
            BTreeMap::new()
        };

        // Collect all env specs from components
        let mut all_env: BTreeMap<String, (String, Option<String>)> = BTreeMap::new();
        for component in components {
            for env_spec in &component.env {
                if !all_env.contains_key(&env_spec.name) {
                    all_env.insert(
                        env_spec.name.clone(),
                        (env_spec.description.clone(), env_spec.default.clone()),
                    );
                }
            }
        }

        // Build output in TOML table format
        let mut lines = vec![
            "# Environment configuration for jlo setup".to_string(),
            "# Edit values as needed before running install.sh".to_string(),
            String::new(),
        ];

        for (name, (description, default)) in &all_env {
            lines.push(format!("[{}]", name));

            // Use existing value if present, otherwise default
            let value = if let Some(existing_table) = existing.get(name) {
                existing_table
                    .get("value")
                    .cloned()
                    .unwrap_or_else(|| default.clone().unwrap_or_default())
            } else {
                default.clone().unwrap_or_default()
            };
            lines.push(format!("value = \"{}\"", value));

            // Preserve existing note if present, otherwise use component description
            let note = existing
                .get(name)
                .and_then(|t| t.get("note").cloned())
                .unwrap_or_else(|| description.clone());
            if !note.is_empty() {
                lines.push(format!("note = \"{}\"", note));
            }

            lines.push(String::new());
        }

        Ok(lines.join("\n"))
    }

    /// Parse env.toml content into table name -> key/value pairs.
    fn parse_env_toml(
        content: &str,
    ) -> Result<BTreeMap<String, BTreeMap<String, String>>, AppError> {
        let data: toml::Value =
            toml::from_str(content).map_err(|e| AppError::MalformedEnvToml(e.to_string()))?;

        let mut result: BTreeMap<String, BTreeMap<String, String>> = BTreeMap::new();

        if let toml::Value::Table(table) = data {
            for (key, value) in table {
                if let toml::Value::Table(inner) = value {
                    let mut inner_map = BTreeMap::new();
                    for (k, v) in inner {
                        if let toml::Value::String(s) = v {
                            inner_map.insert(k, s);
                        }
                    }
                    result.insert(key, inner_map);
                }
            }
        }

        Ok(result)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::setup::EnvSpec;

    fn make_component(name: &str, env: Vec<EnvSpec>) -> Component {
        Component {
            name: name.to_string(),
            summary: format!("{} component", name),
            dependencies: vec![],
            env,
            script_content: format!("echo {}", name),
        }
    }

    #[test]
    fn generate_script_with_header() {
        let components = vec![make_component("test", vec![])];

        let script = Generator::generate_install_script(&components);

        assert!(script.starts_with("#!/usr/bin/env bash"));
        assert!(script.contains("set -euo pipefail"));
        assert!(script.contains("Generated by jlo setup"));
    }

    #[test]
    fn generate_script_with_sections() {
        let components = vec![make_component("alpha", vec![]), make_component("beta", vec![])];

        let script = Generator::generate_install_script(&components);

        assert!(script.contains("# alpha: alpha component"));
        assert!(script.contains("# beta: beta component"));
        assert!(script.contains("echo alpha"));
        assert!(script.contains("echo beta"));
    }

    #[test]
    fn merge_env_toml_creates_new() {
        let components = vec![make_component(
            "test",
            vec![EnvSpec {
                name: "TEST_VAR".to_string(),
                description: "A test variable".to_string(),
                default: Some("default_value".to_string()),
            }],
        )];

        let result = Generator::merge_env_toml(&components, None).unwrap();

        assert!(result.contains("[TEST_VAR]"));
        assert!(result.contains("value = \"default_value\""));
        assert!(result.contains("note = \"A test variable\""));
    }

    #[test]
    fn merge_env_toml_preserves_existing() {
        use std::io::Write;
        let temp_dir = tempfile::tempdir().unwrap();
        let env_path = temp_dir.path().join("env.toml");

        let mut file = std::fs::File::create(&env_path).unwrap();
        writeln!(file, "[TEST_VAR]").unwrap();
        writeln!(file, "value = \"custom_value\"").unwrap();
        writeln!(file, "note = \"Custom note\"").unwrap();
        drop(file);

        let components = vec![make_component(
            "test",
            vec![EnvSpec {
                name: "TEST_VAR".to_string(),
                description: "A test variable".to_string(),
                default: Some("default_value".to_string()),
            }],
        )];

        let result = Generator::merge_env_toml(&components, Some(&env_path)).unwrap();

        assert!(result.contains("value = \"custom_value\""), "should preserve existing value");
        assert!(result.contains("note = \"Custom note\""), "should preserve existing note");
    }

    #[test]
    fn merge_env_toml_adds_new_keys() {
        use std::io::Write;
        let temp_dir = tempfile::tempdir().unwrap();
        let env_path = temp_dir.path().join("env.toml");

        let mut file = std::fs::File::create(&env_path).unwrap();
        writeln!(file, "[EXISTING]").unwrap();
        writeln!(file, "value = \"existing\"").unwrap();
        drop(file);

        let components = vec![make_component(
            "test",
            vec![
                EnvSpec {
                    name: "EXISTING".to_string(),
                    description: "Existing var".to_string(),
                    default: Some("default".to_string()),
                },
                EnvSpec {
                    name: "NEW_VAR".to_string(),
                    description: "New var".to_string(),
                    default: Some("new_default".to_string()),
                },
            ],
        )];

        let result = Generator::merge_env_toml(&components, Some(&env_path)).unwrap();

        assert!(result.contains("[EXISTING]"));
        assert!(result.contains("value = \"existing\""), "should preserve existing");
        assert!(result.contains("[NEW_VAR]"));
        assert!(result.contains("value = \"new_default\""), "should add new with default");
    }
}
