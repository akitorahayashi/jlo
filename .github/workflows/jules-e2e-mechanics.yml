name: Jules E2E Mechanics

on:
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  test-pr-automerge:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: jules
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Resolve observer branch prefix
        id: branch
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f ".jules/JULES.md" ]; then
            echo "Missing .jules/JULES.md in the jules branch." >&2
            exit 1
          fi

          pattern=$(grep -n "Observers:" .jules/JULES.md | head -n 1 | sed -n 's/.*`\(jules-[^`]*\)`/\1/p')
          if [ -z "$pattern" ]; then
            echo "Could not resolve observer branch pattern from .jules/JULES.md." >&2
            exit 1
          fi

          prefix="${pattern%%<*}"
          if [ -z "$prefix" ]; then
            echo "Observer branch prefix is empty." >&2
            exit 1
          fi

          echo "prefix=$prefix" >> "$GITHUB_OUTPUT"

      - name: Create test branch
        shell: bash
        run: |
          set -euo pipefail
          RANDOM_ID=$(printf '%04x' "$RANDOM")
          BRANCH="${{ steps.branch.outputs.prefix }}${RANDOM_ID}"

          # Determine Workstream (jlo init creates 'generic')
          WORKSTREAM="generic"
          if [ ! -d ".jules/workstreams/$WORKSTREAM" ]; then
             echo "Workstream '$WORKSTREAM' not found in .jules/workstreams/." >&2
             WORKSTREAM=$(ls -1 .jules/workstreams | head -n 1 || true)
             if [ -z "$WORKSTREAM" ]; then
                echo "No workstreams found." >&2
                exit 1
             fi
          fi

          ROLE=$(find .jules/roles/observers -mindepth 1 -maxdepth 1 -type d -printf "%f\n" | head -n 1 || true)
          if [ -z "$ROLE" ]; then
            echo "No observer roles found under .jules/roles/observers." >&2
            exit 1
          fi

          escape_sed() {
            printf '%s' "$1" | sed -e 's/[\\&#]/\\&/g'
          }

          render_template() {
            local template="$1"
            local output="$2"
            shift 2

            cp "$template" "$output"
            while [ "$#" -gt 1 ]; do
              local placeholder="$1"
              local value="$2"
              shift 2
              value=$(escape_sed "$value")
              sed -i "s#$placeholder#$value#g" "$output"
            done
          }

          extract_template_value() {
            local file="$1"
            local key="$2"
            local line

            line=$(grep -E "^[[:space:]]*$key:" "$file" | head -n 1 | sed -E 's/^[^:]*:[[:space:]]*//')
            line=${line%%#*}
            line=$(printf '%s' "$line" | tr -d '"' | xargs)
            printf '%s' "$line"
          }

          pick_enum_value() {
            local raw="$1"
            IFS='|' read -r -a parts <<< "$raw"
            local count=${#parts[@]}
            if [ "$count" -eq 0 ]; then
              return 1
            fi
            local index=$((count / 2))
            printf '%s' "${parts[$index]}"
          }

          OBSERVER_TEMPLATE=".jules/roles/observers/event.yml"
          # DECIDER_TEMPLATE is not strictly needed for the mechanics test if we only create an event

          CONFIDENCE_ENUM=$(extract_template_value "$OBSERVER_TEMPLATE" "confidence")
          if [ -z "$CONFIDENCE_ENUM" ]; then
            echo "Failed to read confidence enum from $OBSERVER_TEMPLATE." >&2
            exit 1
          fi
          EVENT_CONFIDENCE=$(pick_enum_value "$CONFIDENCE_ENUM")

          # Placeholder logic matches .jules/roles/observers/event.yml
          # id: "YYYY-MM-DD_HHMMSS_<role>_<id>"
          DATE_STR="$(date -u +%Y-%m-%d)"
          TIME_STR="$(date -u +%H%M%S)"
          EVENT_ID="${DATE_STR}_${TIME_STR}_${ROLE}_${RANDOM_ID}"
          
          # Path: .jules/workstreams/<workstream>/events/<id>.yml
          EVENT_PATH=".jules/workstreams/$WORKSTREAM/events/${EVENT_ID}.yml"
          EVENT_TEMPLATE=".jules/roles/observers/event.yml"

          mkdir -p ".jules/workstreams/$WORKSTREAM/events"

          render_template \
            "$EVENT_TEMPLATE" \
            "$EVENT_PATH" \
            "YYYY-MM-DD_HHMMSS_<role>_<id>" "$EVENT_ID" \
            "YYYY-MM-DD" "$DATE_STR" \
            "<role>" "$ROLE" \
            "low|medium|high" "$EVENT_CONFIDENCE" \
            "<short descriptive title>" "E2E observer event" \
            "<concise statement of the observation>" "Synthetic observer event created for auto-merge validation." \
            "<repo-relative path>" "README.md" \
            "<line number or symbol>" "# .jules/" \
            "<why this supports the statement>" "Validates the observer event flow for e2e mechanics." \
            "<tag>" "e2e"

          git checkout -b "$BRANCH"
          git add "$EVENT_PATH"
          git commit -m "E2E: Observer event for workflow validation $RANDOM_ID"
          git push origin "$BRANCH"

          echo "BRANCH=$BRANCH" >> "$GITHUB_ENV"

      - name: Create PR
        env:
          GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
        run: |
          PR_URL=$(gh pr create \
            --base jules \
            --head "$BRANCH" \
            --title "[E2E Test] Workflow validation" \
            --body "Automated E2E test. Will be auto-merged and deleted.")

          echo "Created PR: $PR_URL"
          echo "PR_URL=$PR_URL" >> "$GITHUB_ENV"

      - name: Wait for merge
        id: wait-merge
        env:
          GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
        run: |
          echo "Waiting for auto-merge..."

          for i in {1..120}; do
            STATE=$(gh pr view "$PR_URL" --json state -q '.state')

            if [ "$STATE" = "MERGED" ]; then
              echo "‚úÖ PR merged successfully"
              echo "result=success" >> "$GITHUB_OUTPUT"
              exit 0
            elif [ "$STATE" = "CLOSED" ]; then
              echo "‚ùå PR was closed but not merged"
              echo "result=closed" >> "$GITHUB_OUTPUT"
              exit 1
            fi

            echo "State: $STATE - Waiting... ($i/120)"
            sleep 10
          done

          echo "‚ùå Timeout waiting for merge"
          echo "result=timeout" >> "$GITHUB_OUTPUT"
          exit 1

      - name: Cleanup
        if: always()
        env:
          GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
        run: |
          echo "Run Result: ${{ steps.wait-merge.outcome }}"

          if [ -n "$PR_URL" ]; then
             STATE=$(gh pr view "$PR_URL" --json state -q '.state')

             if [ "$STATE" != "MERGED" ]; then
               echo "üßπ Closing failed/stalled PR: $PR_URL"
               gh pr close "$PR_URL" --delete-branch || echo "‚ö†Ô∏è Failed to close PR (might be already closed)"
             else
               echo "‚ú® PR was successfully merged. No cleanup needed."
             fi

          elif [ -n "$BRANCH" ]; then
             echo "üßπ Deleting via git push: $BRANCH"
             git push origin --delete "$BRANCH" || echo "‚ö†Ô∏è Failed to delete branch (might not exist)"
          fi
