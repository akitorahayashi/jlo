name: Jules Workflows
on:
  schedule:
  - cron: 0 20 * * *
  workflow_dispatch:
    inputs:
      entry_point:
        description: Start from layer
        type: choice
        options:
        - narrator
        - observers
        - deciders
        - planners
        - implementers
        - innovators
        default: narrator
      wait_minutes:
        description: Minutes to wait between layers (Jules async processing time)
        type: number
        default: 30
      routing_labels:
        description: Issue labels eligible for planner/implementer routing (comma-separated)
        type: string
        default: bugs,feats,refacts,tests,docs
      mock:
        description: Run in mock mode (creates branches/PRs without Jules API)
        type: boolean
        default: false
  workflow_call:
    inputs:
      entry_point:
        type: string
        default: narrator
      wait_minutes:
        type: number
        default: 30
      routing_labels:
        type: string
        default: bugs,feats,refacts,tests,docs
      mock:
        type: boolean
        default: false
permissions:
  contents: write
  issues: write
  pull-requests: write
concurrency:
  group: jules
  cancel-in-progress: false
env:
  WAIT_MINUTES: ${{ inputs.wait_minutes || 30 }}
  ROUTING_LABELS: ${{ inputs.routing_labels || 'bugs,feats,refacts,tests,docs' }}
  MOCK_MODE: ${{ github.event.inputs.mock || inputs.mock }}
  JULES_MOCK_TAG: ${{ format('mock-run-{0}', github.run_id) }}
  JLO_RUN_FLAGS: ${{ (github.event.inputs.mock || inputs.mock) && '--mock' || '' }}
jobs:
  bootstrap:
    if: vars.JLO_PAUSED != 'true' || github.event_name != 'schedule'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.JLO_BOT_TOKEN }}
    - name: Configure Git
      uses: ./.github/actions/configure-git
    - name: Ensure jules branch
      run: |
        set -euo pipefail
        if git rev-parse --verify origin/jules >/dev/null 2>&1; then
          echo "jules branch exists, checking out"
          git checkout jules
        else
          echo "Creating orphan jules branch from HEAD"
          git checkout --orphan jules
          git rm -rf . 2>/dev/null || true
          git clean -fd
          git commit --allow-empty -m "chore: initialize jules branch"
        fi
    - name: Install jlo
      uses: ./.github/actions/install-jlo
    - name: Bootstrap runtime workspace
      run: jlo workflow bootstrap
    - name: Project control-plane overlay
      run: |
        set -euo pipefail
        DEFAULT_BRANCH=$(git remote show origin 2>/dev/null | awk '/HEAD branch/ {print $NF}')
        DEFAULT_BRANCH=${DEFAULT_BRANCH:-main}
        echo "Projecting .jlo/ intent from ${DEFAULT_BRANCH} into .jules/"

        # Extract .jlo/ file listing from control branch
        JLO_FILES=$(git ls-tree -r --name-only "origin/${DEFAULT_BRANCH}" -- .jlo/ 2>/dev/null || true)
        if [ -z "$JLO_FILES" ]; then
          echo "No .jlo/ files found on ${DEFAULT_BRANCH}; skipping projection"
          exit 0
        fi

        echo "$JLO_FILES" | while IFS= read -r jlo_path; do
          # Skip the version pin â€” already handled by bootstrap
          [ "$jlo_path" = ".jlo/.jlo-version" ] && continue

          # Map .jlo/X to .jules/X
          jules_path=".jules/${jlo_path#.jlo/}"
          mkdir -p "$(dirname "$jules_path")"
          git show "origin/${DEFAULT_BRANCH}:${jlo_path}" > "$jules_path"
          echo "  projected: ${jlo_path} -> ${jules_path}"
        done
    - name: Commit and push changes
      id: bootstrap
      run: |
        set -euo pipefail
        if [ -n "$(git status --porcelain .jules)" ]; then
          git add .jules/
          git commit -m "chore: bootstrap .jules/ runtime workspace [jlo $(jlo --version | awk '{print $2}')]"
          git push origin jules
          echo "committed=true" >> "$GITHUB_OUTPUT"
        else
          echo "committed=false" >> "$GITHUB_OUTPUT"
        fi
  run-narrator:
    needs:
    - bootstrap
    if: |-
      needs.bootstrap.result == 'success' && (vars.JLO_PAUSED != 'true' || github.event_name != 'schedule') && (
        github.event_name == 'schedule' ||
        (github.event_name == 'workflow_dispatch' && (github.event.inputs.entry_point || 'narrator') == 'narrator') ||
        (github.event_name == 'workflow_call' && (inputs.entry_point || 'narrator') == 'narrator')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
    - uses: actions/checkout@v4
      with:
        ref: jules
        fetch-depth: 0
        token: ${{ secrets.JLO_BOT_TOKEN }}
    - name: Configure Git
      uses: ./.github/actions/configure-git
    - name: Install jlo
      uses: ./.github/actions/install-jlo
    - name: Run narrator
      id: run
      run: jlo workflow run global narrator ${{ env.JLO_RUN_FLAGS }}
    - name: Validate workspace (fail-fast)
      run: jlo doctor
  wait-after-narrator:
    needs: run-narrator
    if: |
      always() &&
      needs.run-narrator.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
    - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
      id: wait
      shell: bash
      run: |
        set -euo pipefail
        trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

        if [ "${{ env.MOCK_MODE }}" = "true" ]; then
          TOTAL_SECONDS=30
          echo "Mock mode enabled: overriding wait to 30 seconds."
        else
          TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
        fi

        if [ "$TOTAL_SECONDS" -le 0 ]; then
          echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
          echo "json={}" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        if [ -n "narrator" ]; then
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process narrator..."
        else
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
        fi
        ELAPSED=0
        INTERVAL=5
        while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
          STEP=$INTERVAL
          REMAINING=$((TOTAL_SECONDS - ELAPSED))
          if [ "$REMAINING" -lt "$STEP" ]; then
            STEP=$REMAINING
          fi
          sleep "$STEP" &
          wait $!
          ELAPSED=$((ELAPSED + STEP))
          echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
        done
        echo "Wait complete."
        echo "json={}" >> "$GITHUB_OUTPUT"
  generate-workstream-matrix:
    needs: wait-after-narrator
    if: |
      always() &&
      (vars.JLO_PAUSED != 'true' || github.event_name != 'schedule') &&
      (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      (needs.wait-after-narrator.result == 'success' || needs.wait-after-narrator.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      json: ${{ steps.matrix.outputs.json }}
    steps:
    - uses: actions/checkout@v4
      with:
        ref: jules
        fetch-depth: 0
        token: ${{ secrets.JLO_BOT_TOKEN }}
    - name: Install jlo
      uses: ./.github/actions/install-jlo
    - name: Generate workstream matrix
      id: matrix
      run: jlo workflow matrix workstreams
  run-innovators-1:
    needs:
    - generate-workstream-matrix
    if: |
      always() &&
            needs.generate-workstream-matrix.result == 'success' &&
            fromJSON(needs.generate-workstream-matrix.outputs.json).has_workstreams == true
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
    - uses: actions/checkout@v4
      with:
        ref: jules
        fetch-depth: 0
        token: ${{ secrets.JLO_BOT_TOKEN }}
    - name: Configure Git
      uses: ./.github/actions/configure-git
    - name: Install jlo
      uses: ./.github/actions/install-jlo
    - name: Run innovators (first pass) for each workstream
      id: run
      env:
        MATRIX_OUTPUT: ${{ needs.generate-workstream-matrix.outputs.json }}
      run: |
        set -euo pipefail
        echo "$MATRIX_OUTPUT" | jq -r '.matrix.include[].workstream' | while read ws; do
          [ -z "$ws" ] && continue
          echo "Running innovators for workstream: $ws"
          jlo workflow run "$ws" innovators ${{ env.JLO_RUN_FLAGS }} --phase creation
        done
  run-observers:
    needs:
    - generate-workstream-matrix
    if: |
      always() &&
            needs.generate-workstream-matrix.result == 'success' &&
            fromJSON(needs.generate-workstream-matrix.outputs.json).has_workstreams == true
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
    - uses: actions/checkout@v4
      with:
        ref: jules
        fetch-depth: 0
        token: ${{ secrets.JLO_BOT_TOKEN }}
    - name: Configure Git
      uses: ./.github/actions/configure-git
    - name: Install jlo
      uses: ./.github/actions/install-jlo
    - name: Run observers for each workstream
      id: run
      env:
        MATRIX_OUTPUT: ${{ needs.generate-workstream-matrix.outputs.json }}
      run: |
        set -euo pipefail
        echo "$MATRIX_OUTPUT" | jq -r '.matrix.include[].workstream' | while read ws; do
          [ -z "$ws" ] && continue
          echo "Running observers for workstream: $ws"
          jlo workflow run "$ws" observers ${{ env.JLO_RUN_FLAGS }}
        done
  wait-after-observers:
    needs: run-observers
    if: |
      always() &&
      needs.run-observers.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
    - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
      id: wait
      shell: bash
      run: |
        set -euo pipefail
        trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

        if [ "${{ env.MOCK_MODE }}" = "true" ]; then
          TOTAL_SECONDS=30
          echo "Mock mode enabled: overriding wait to 30 seconds."
        else
          TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
        fi

        if [ "$TOTAL_SECONDS" -le 0 ]; then
          echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
          echo "json={}" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        if [ -n "observers" ]; then
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process observers..."
        else
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
        fi
        ELAPSED=0
        INTERVAL=5
        while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
          STEP=$INTERVAL
          REMAINING=$((TOTAL_SECONDS - ELAPSED))
          if [ "$REMAINING" -lt "$STEP" ]; then
            STEP=$REMAINING
          fi
          sleep "$STEP" &
          wait $!
          ELAPSED=$((ELAPSED + STEP))
          echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
        done
        echo "Wait complete."
        echo "json={}" >> "$GITHUB_OUTPUT"
  wait-after-innovators-1:
    needs: run-innovators-1
    if: |
      always() &&
      needs.run-innovators-1.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
    - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
      id: wait
      shell: bash
      run: |
        set -euo pipefail
        trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

        if [ "${{ env.MOCK_MODE }}" = "true" ]; then
          TOTAL_SECONDS=30
          echo "Mock mode enabled: overriding wait to 30 seconds."
        else
          TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
        fi

        if [ "$TOTAL_SECONDS" -le 0 ]; then
          echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
          echo "json={}" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        if [ -n "innovators (first pass)" ]; then
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process innovators (first pass)..."
        else
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
        fi
        ELAPSED=0
        INTERVAL=5
        while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
          STEP=$INTERVAL
          REMAINING=$((TOTAL_SECONDS - ELAPSED))
          if [ "$REMAINING" -lt "$STEP" ]; then
            STEP=$REMAINING
          fi
          sleep "$STEP" &
          wait $!
          ELAPSED=$((ELAPSED + STEP))
          echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
        done
        echo "Wait complete."
        echo "json={}" >> "$GITHUB_OUTPUT"
  run-innovators-2:
    needs:
    - generate-workstream-matrix
    - wait-after-observers
    - wait-after-innovators-1
    if: |
      always() &&
            fromJSON(needs.generate-workstream-matrix.outputs.json).has_workstreams == true &&
            (needs.wait-after-observers.result == 'success' || needs.wait-after-observers.result == 'skipped') &&
            (needs.wait-after-innovators-1.result == 'success' || needs.wait-after-innovators-1.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
    - uses: actions/checkout@v4
      with:
        ref: jules
        fetch-depth: 0
        token: ${{ secrets.JLO_BOT_TOKEN }}
    - name: Configure Git
      uses: ./.github/actions/configure-git
    - name: Install jlo
      uses: ./.github/actions/install-jlo
    - name: Run innovators (second pass) for each workstream
      id: run
      env:
        MATRIX_OUTPUT: ${{ needs.generate-workstream-matrix.outputs.json }}
      run: |
        set -euo pipefail
        echo "$MATRIX_OUTPUT" | jq -r '.matrix.include[].workstream' | while read ws; do
          [ -z "$ws" ] && continue
          echo "Running innovators for workstream: $ws"
          jlo workflow run "$ws" innovators ${{ env.JLO_RUN_FLAGS }} --phase refinement
        done
  wait-after-innovators-2:
    needs: run-innovators-2
    if: |
      always() &&
      needs.run-innovators-2.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
    - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
      id: wait
      shell: bash
      run: |
        set -euo pipefail
        trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

        if [ "${{ env.MOCK_MODE }}" = "true" ]; then
          TOTAL_SECONDS=30
          echo "Mock mode enabled: overriding wait to 30 seconds."
        else
          TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
        fi

        if [ "$TOTAL_SECONDS" -le 0 ]; then
          echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
          echo "json={}" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        if [ -n "innovators (second pass)" ]; then
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process innovators (second pass)..."
        else
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
        fi
        ELAPSED=0
        INTERVAL=5
        while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
          STEP=$INTERVAL
          REMAINING=$((TOTAL_SECONDS - ELAPSED))
          if [ "$REMAINING" -lt "$STEP" ]; then
            STEP=$REMAINING
          fi
          sleep "$STEP" &
          wait $!
          ELAPSED=$((ELAPSED + STEP))
          echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
        done
        echo "Wait complete."
        echo "json={}" >> "$GITHUB_OUTPUT"
  publish-proposals:
    needs:
    - generate-workstream-matrix
    - wait-after-innovators-2
    if: |
      always() &&
      fromJSON(needs.generate-workstream-matrix.outputs.json).has_workstreams == true &&
      (needs.wait-after-innovators-2.result == 'success' || needs.wait-after-innovators-2.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
    - uses: actions/checkout@v4
      with:
        ref: jules
        fetch-depth: 0
        token: ${{ secrets.JLO_BOT_TOKEN }}
    - name: Configure Git
      uses: ./.github/actions/configure-git
    - name: Install jlo
      uses: ./.github/actions/install-jlo
    - name: Publish proposals for each workstream
      env:
        WORKSTREAMS_OUTPUT: ${{ needs.generate-workstream-matrix.outputs.json }}
      run: |
        set -euo pipefail
        echo "$WORKSTREAMS_OUTPUT" | jq -r '.matrix.include[].workstream' | while read ws; do
          echo "Publishing proposals for workstream: $ws"
          jlo workflow workstreams publish-proposals "$ws"
        done
  generate-decider-matrix:
    needs:
    - generate-workstream-matrix
    - wait-after-observers
    if: |
      always() &&
      fromJSON(needs.generate-workstream-matrix.outputs.json).has_workstreams == true &&
      (needs.wait-after-observers.result == 'success' || needs.wait-after-observers.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      json: ${{ steps.matrix.outputs.json }}
    steps:
    - uses: actions/checkout@v4
      with:
        ref: jules
        fetch-depth: 0
    - name: Install jlo
      uses: ./.github/actions/install-jlo
    - name: Generate decider matrix from pending events
      id: matrix
      env:
        WORKSTREAMS_OUTPUT: ${{ needs.generate-workstream-matrix.outputs.json }}
      run: |
        WORKSTREAMS_JSON=$(echo "$WORKSTREAMS_OUTPUT" | jq -c '.matrix')
        jlo workflow matrix pending-workstreams --workstreams-json "$WORKSTREAMS_JSON"
  run-deciders:
    needs:
    - generate-decider-matrix
    if: |
      always() &&
            needs.generate-decider-matrix.result == 'success' &&
            fromJSON(needs.generate-decider-matrix.outputs.json).has_pending == true
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
    - uses: actions/checkout@v4
      with:
        ref: jules
        fetch-depth: 0
        token: ${{ secrets.JLO_BOT_TOKEN }}
    - name: Configure Git
      uses: ./.github/actions/configure-git
    - name: Install jlo
      uses: ./.github/actions/install-jlo
    - name: Run deciders for each pending workstream
      id: run
      env:
        MATRIX_OUTPUT: ${{ needs.generate-decider-matrix.outputs.json }}
      run: |
        set -euo pipefail
        echo "$MATRIX_OUTPUT" | jq -r '.matrix.include[].workstream' | while read ws; do
          [ -z "$ws" ] && continue
          echo "Running deciders for workstream: $ws"
          jlo workflow run "$ws" deciders ${{ env.JLO_RUN_FLAGS }}
        done
  wait-after-deciders:
    needs: run-deciders
    if: |
      always() &&
      needs.run-deciders.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
    - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
      id: wait
      shell: bash
      run: |
        set -euo pipefail
        trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

        if [ "${{ env.MOCK_MODE }}" = "true" ]; then
          TOTAL_SECONDS=30
          echo "Mock mode enabled: overriding wait to 30 seconds."
        else
          TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
        fi

        if [ "$TOTAL_SECONDS" -le 0 ]; then
          echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
          echo "json={}" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        if [ -n "deciders" ]; then
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process deciders..."
        else
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
        fi
        ELAPSED=0
        INTERVAL=5
        while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
          STEP=$INTERVAL
          REMAINING=$((TOTAL_SECONDS - ELAPSED))
          if [ "$REMAINING" -lt "$STEP" ]; then
            STEP=$REMAINING
          fi
          sleep "$STEP" &
          wait $!
          ELAPSED=$((ELAPSED + STEP))
          echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
        done
        echo "Wait complete."
        echo "json={}" >> "$GITHUB_OUTPUT"
  generate-planner-matrix:
    needs:
    - generate-workstream-matrix
    - generate-decider-matrix
    - run-deciders
    - wait-after-deciders
    if: |
      always() &&
      fromJSON(needs.generate-workstream-matrix.outputs.json).has_workstreams == true &&
      (needs.generate-decider-matrix.result == 'success' || needs.generate-decider-matrix.result == 'skipped') &&
      (needs.run-deciders.result == 'success' || needs.run-deciders.result == 'skipped') &&
      (needs.wait-after-deciders.result == 'success' || needs.wait-after-deciders.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      json: ${{ steps.matrix.outputs.json }}
    steps:
    - uses: actions/checkout@v4
      with:
        ref: jules
        fetch-depth: 0
    - name: Install jlo
      uses: ./.github/actions/install-jlo
    - name: Generate planner and implementer matrices
      id: matrix
      env:
        WORKSTREAMS_OUTPUT: ${{ needs.generate-workstream-matrix.outputs.json }}
      run: |
        WORKSTREAMS_JSON=$(echo "$WORKSTREAMS_OUTPUT" | jq -c '.matrix')
        jlo workflow matrix routing --workstreams-json "$WORKSTREAMS_JSON" --routing-labels "$ROUTING_LABELS"
  run-planners:
    needs:
    - generate-planner-matrix
    if: |
      always() &&
            needs.generate-planner-matrix.result == 'success' &&
            fromJSON(needs.generate-planner-matrix.outputs.json).has_planners == true
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
    - uses: actions/checkout@v4
      with:
        ref: jules
        fetch-depth: 0
        token: ${{ secrets.JLO_BOT_TOKEN }}
    - name: Configure Git
      uses: ./.github/actions/configure-git
    - name: Install jlo
      uses: ./.github/actions/install-jlo
    - name: Run planners for each workstream
      id: run
      env:
        MATRIX_OUTPUT: ${{ needs.generate-planner-matrix.outputs.json }}
      run: |
        set -euo pipefail
        echo "$MATRIX_OUTPUT" | jq -r '.planner_matrix.include[].workstream // empty' | sort -u | while read ws; do
          [ -z "$ws" ] && continue
          echo "Running planners for workstream: $ws"
          jlo workflow run "$ws" planners ${{ env.JLO_RUN_FLAGS }}
        done
  wait-after-planners:
    needs: run-planners
    if: |
      always() &&
      needs.run-planners.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
    - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
      id: wait
      shell: bash
      run: |
        set -euo pipefail
        trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

        if [ "${{ env.MOCK_MODE }}" = "true" ]; then
          TOTAL_SECONDS=30
          echo "Mock mode enabled: overriding wait to 30 seconds."
        else
          TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
        fi

        if [ "$TOTAL_SECONDS" -le 0 ]; then
          echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
          echo "json={}" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        if [ -n "planners" ]; then
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process planners..."
        else
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
        fi
        ELAPSED=0
        INTERVAL=5
        while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
          STEP=$INTERVAL
          REMAINING=$((TOTAL_SECONDS - ELAPSED))
          if [ "$REMAINING" -lt "$STEP" ]; then
            STEP=$REMAINING
          fi
          sleep "$STEP" &
          wait $!
          ELAPSED=$((ELAPSED + STEP))
          echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
        done
        echo "Wait complete."
        echo "json={}" >> "$GITHUB_OUTPUT"
  run-implementers:
    needs:
    - generate-planner-matrix
    if: |
      always() &&
            needs.generate-planner-matrix.result == 'success' &&
            fromJSON(needs.generate-planner-matrix.outputs.json).has_implementers == true
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
      TARGET_BRANCH: ${{ vars.JULES_TARGET_BRANCH || 'main' }}
    steps:
    - uses: actions/checkout@v4
      with:
        ref: jules
        fetch-depth: 0
        token: ${{ secrets.JLO_BOT_TOKEN }}
    - name: Configure Git
      uses: ./.github/actions/configure-git
    - name: Install jlo
      uses: ./.github/actions/install-jlo
    - name: Run implementers for each workstream
      id: run
      env:
        MATRIX_OUTPUT: ${{ needs.generate-planner-matrix.outputs.json }}
      run: |
        set -euo pipefail
        echo "$MATRIX_OUTPUT" | jq -r '.implementer_matrix.include[].workstream // empty' | sort -u | while read ws; do
          [ -z "$ws" ] && continue
          echo "Running implementers for workstream: $ws"
          jlo workflow run "$ws" implementers ${{ env.JLO_RUN_FLAGS }}
        done
  wait-after-implementers:
    needs: run-implementers
    if: |
      always() &&
      needs.run-implementers.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
    - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
      id: wait
      shell: bash
      run: |
        set -euo pipefail
        trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

        if [ "${{ env.MOCK_MODE }}" = "true" ]; then
          TOTAL_SECONDS=30
          echo "Mock mode enabled: overriding wait to 30 seconds."
        else
          TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
        fi

        if [ "$TOTAL_SECONDS" -le 0 ]; then
          echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
          echo "json={}" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        if [ -n "implementers" ]; then
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process implementers..."
        else
          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
        fi
        ELAPSED=0
        INTERVAL=5
        while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
          STEP=$INTERVAL
          REMAINING=$((TOTAL_SECONDS - ELAPSED))
          if [ "$REMAINING" -lt "$STEP" ]; then
            STEP=$REMAINING
          fi
          sleep "$STEP" &
          wait $!
          ELAPSED=$((ELAPSED + STEP))
          echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
        done
        echo "Wait complete."
        echo "json={}" >> "$GITHUB_OUTPUT"
